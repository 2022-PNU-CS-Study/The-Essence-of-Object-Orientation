# 객체지향 바르게 이해하기 - 인터페이스

### 메시지

객체가 다른 객체에게 접근할 수 있는 유일한 방법은 요청을 전송하는 것 뿐이다. 그리고 이 요청을 우리는 메시지라고 부른다. 메시지는 객체로 하여금 자신의 책임을 수행하게 만드는 유일한 방법이다.

그리고 객체는 메시지를 처리하기 위한 방법을 자율적으로 선택할 수 있다. 외부의 객체는 메시지에 관해서만 볼 수 있고 객체 내부는 볼 수 없기 때문에 자연스럽게 객체의 외부와 내부가 분리된다.

> 객체지향 애플리케이션은 클래스를 이용해 만들어지지만 메시지를 통해 정의된다.

클래스가 코드를 구현하기 위해 사용할 수 있는 중요한 추상화 도구인 것은 사실이지만 객체지향의 강력함은 클래스가 아니라 객체들이 주고받는 메시지로 부터 나온다.

객체지향 설계의 중심에는 메시지가 위치하고 메시지를 중심으로 설계해야한다. 메시지를 중심으로 설계된 구조는 유연하고 확장 가능하며 재사용 가능하다.

설계의 순서는 반드시 메시지가 먼저여야한다. 메시지를 결정하고 이를 수행할 객체를 설계하자.

### 메서드

객체가 메시지를 처리하기 위해 내부적으로 선택하는 방법을 메서드라고 한다. 메시지는 '어떻게' 수행될 것인지는 명시하지 않는다. 메시지는 단지 오퍼레이션을 통해 '무엇’이 실행되기를 바라는지만 명시하며, 어떤 메서드를 선택할 것인지는 전적으로 수신자의 결정에 좌우된다.

메시지를 수신한 객체가 실행 시간에 메서드를 선택할 수 있다는 사실은 다른 프로그래밍 언어와 객체지향 프로그래밍 언어를 구분 짓는 핵심적인 특징 중 하나다. 이것은 프로시저 호출에 대한 실행 코드를 컴파일 시간에 결정하는 절차적인 언어와 확연히 구분되는 특징이다.

### 다형성

다형성이란 서로 다른 유형의 객체가 동일한 메시지에 대해 서로 다르게 반응하는 것을 의미한다.

서로 다른 객체들이 다형성을 만족시킨다는 것은 객체들이 동일한 책임을 공유한다는 것을 의미한다. 다형성에서 중요한 것은 메시지 송신자의 관점이다. 메시지 수신자들이 동일한 오퍼레이션을 서로 다른 방식으로 처리하더라도 메시지 송신자의 관점에서 이 객체들은 동일한 책임을 수행하는 것이다.

앞서 설명했던 다형성의 정의를 다르게 말하면, 다형성은 동일한 역할을 수행할 수 있는 객체들 사이의 대체 가능성을 의미한다. 동일한 메시지를 처리할 수 있기 때문이다.

그리고 다형성은 이 대체 가능성을 이용해 설계를 유연하고 재사용 가능하게 만든다. 다형성을 이용하면 송신자가 수신자의 종류를 모르더라도 메시지를 전송할 수 있다. 즉, 다형성은 수신자의 종류를 캡슐화한다.

객체지향 용어를 이용해 표현하자면 다형성은 송신자와 수신자 간의 객체 타입에 대한 결합도를 메시지에 대한 결합도로 낮춘다. 다형성을 사용하면 메시지를 이해할 수 있는 어떤 객체와도 협력할 수 있는 유연하고 확장 가능한 구조를 만들 수 있다.

### 인터페이스

일반적으로 인터페이스란 어떤 두 사물이 마주치는 경계 지점에서 서로 상호작용할 수 있게 이어주는 방법이나 장치를 의미한다. 그리고 인터페이스는 다음과 같은 세 가지 특징을 지닌다.

1. 인터페이스의 사용법을 익히기만 하면 내부 구조나 동작 방식을 몰라도 쉽게 대상을 조작하거나 의사를 전달할 수 있다.
2. 인터페이스 자체는 변경하지 않고 단순히 내부 구성이나 작동 방식만을 변경하는 것은 인터페이스 사용자에게 큰 영향을 미치지 않는다.
3. 그 대상이 변경되더라도 동일한 인터페이스를 제공하기만 하면 사용자와의 상호작용에는 아무런 문제가 없다.

객체지향의 세계에서 협력에 참여하는 객체들 역시 인터페이스를 통해 다른 객체와 상호작용한다. 그리고 위의 세가지 특성은 똑같이 적용된다. 다른 객체의 작동방식을 몰라도 상호작용에는 전혀 문제가 없으며 그 인터페이스만 유지된다면 다른 객체로 대체된다고 하더라도 무방하다.

수신 가능한 메시지가 모여 인터페이스를 구성한다. 메시지를 먼저 결정하고 메시지를 수신하여 처리할 객체를 구현하는 과정은 인터페이스가 어떤 방식으로 결정되는지를 명확하게 보여준다.

이말인 즉슨 객체의 인터페이스를 구성하는 것은 객체가 외부로 부터 수신할 수 있는 메시지의 목록이자 수행해야 할 책임의 목록이라는 뜻이다.

**최소 인터페이스 원칙**

인터페이스를 최소로 유지하면 객체의 내부 동작에 대해 가능한 한 적은 정보만 외부에 노출할 수 있다.

이는 까다로운 원칙처럼 들리지만 위에서 설명했던 메시지(책임)을 먼저 결정하고 객체의 구현을 나중에 생각하는 설계 방법을 따르면 자연스럽게 지킬 수 있는 원칙이다. 이 순서를 지키면 객체는 실제로 협력에 필요한 메시지 이외의 불필요한 메시지를 공용 인터페이스에 포함하지 않아도 되기 때문이다.

반대로 클래스를 먼저 생각하고 메시지와 협력에 초점을 맞추지 않고 설계할 경우 불필요한 인터페이스가 외부로 노출되기 쉽다.

> 유일하게 변하지 않는 것은 모든 것이 변한다는 사실뿐이다. - *헤라클레이토스*(Heraclitus of Ephesus)

**인터페이스와 구현의 분리**

객체 지향 설계의 핵심은 객체를 외부에 공개되는 ‘인터페이스’와 내부에 감춰지는 ‘구현’ 이라는 두 개의 분리된 요소로 분할해 설계하는 것이다.

우리는 왜 굳이 힘들고 귀찮게 인터페이스와 구현을 분리해야할까? 왜냐하면 소프트웨어는 항상 변하기 때문이다. 수많은 객체들이 물고 물리며 돌아가는 복잡한 객체지향 세계에서 어떤 한 객체가 변경되었을 때 그 변화가 어디까지 영향을 미칠 지 판단하는 것은 곡예에 가깝다. 객체 구현의 모든 부분이 외부에 공개되어 있다면 변경에 의한 파급 효과가 세계의 구석구석까지 파고들 것이다.

객체의 변경에 의한 파급효과를 감당해야하는 것은 다른 누구도 아닌 개발자인 우리다. 우리는 기계가 아닌 사람인지라 그 변화를 하나하나 추적하는 것은 불가능하다. 이런 가혹하기 그지없는 상황에서 우리가 취했던 마지막 생존 전략이 ‘인터페이스와 구현의 분리' 라는 원칙이다.

소프트웨어의 변경은 불가피하다. 하지만 그 변경이 영향을 미치는 범위를 가능한 한 최소화하자는 것이다. 객체를 인터페이스와 구현으로 분리하면 객체 변화의 영향은 적어도 구현까지만으로 좁혀진다. 해당 객체의 인터페이스를 바라 보고 있는 수많은 다른 객체들은 해당 객체의 구현부가 어떻게 바뀌든 아무런 영향을 받지 않는다. 외부 객체들이 영향을 받는 유일한 순간은 인터페이스가 수정될 때 뿐이다.

인터페이스와 구현의 분리 원칙을 다시 한번 고급스럽게 정리하면 ‘메시지의 송신자와 수신자가 구체적인 구현 부분이 아니라 느슨한 인터페이스에 대해서만 결합되도록 만드는 것' 이다.

정말 아름다운 생존 전략이다.

객체지향이 과거의 개발 방법에 비해 좀 더 유연하고 재사용 가능하다고 알려진 이유는 객체의 내부와 내부를 명확하게 부분하기 때문이다.

객체의 외부와 내부를 명확하게 구분하라. 그러면 설계가 단순하고 유연해지며 변경하기 쉬워질 것이다.

### 객체의 자율성

> 객체가 얼마나 자율적인지가 전체적인 협력의 설계 품질을 결정한다.

> 자율은 곧 추상이다.

객체의 외부와 내부를 구분짓고 외부만 바라볼 수 있게 하는 것은 곧 객체를 자율적인 존재로 바라보게 한다. 객체의 내부를 어떻게 구성하는 지는 객체 자신의 자율이기 때문이다.

- 송신자가 수신자의 세부 구현에 대해 관여하는 순간 객체의 자율성은 없어진다.
- 구현에 관여하지 않는다 하더라도 그 인터페이스가 너무 세세해서 하나의 책임으로 판단하기 힘들다면 그 떄도 자율성은 없어진다.

위에서 인터페이스에 대해 말했던 여러가지 원칙들이 객체의 자율성을 보장하기 위한 원칙이라고도 말할 수 있다.

책임이 자율적일수록 협력이 이해하기 쉬워지고 변경에 유연해진다. 자율적인 책임의 강력함을 느껴보자.

